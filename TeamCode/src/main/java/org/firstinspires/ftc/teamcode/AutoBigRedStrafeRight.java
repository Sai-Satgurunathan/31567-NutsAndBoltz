// Code Generated by Sidekick is for learning and experimentation purposes only.
package org.firstinspires.ftc.teamcode;

import static com.qualcomm.robotcore.hardware.DcMotor.ZeroPowerBehavior.BRAKE;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.util.ElapsedTime;


/*
MAIN CONTROLLER HUB (Facing front of the bot)
************************
	motors ports
		0= launcher
		1= right_front_drive
		2= left_front_drive
		3= left_back_drive

	Servos ports:
		0 = left_feeder
		1 = right_feeder

EXT CONTROLLER HUB
************************
	motors ports
		1= right_back_drive
*/

@com.qualcomm.robotcore.eventloop.opmode.Autonomous(name="AutoBigRedStrafeRight", group="Linear Opmode")
public class AutoBigRedStrafeRight extends LinearOpMode {

    // ===== Drive Motors =====
    private DcMotor frontLeft, frontRight, backLeft, backRight;

    // ===== Launcher =====
    private DcMotorEx launcher;
    private CRServo leftFeeder, rightFeeder;

    // ===== Launcher Constants (MATCH TELEOP) =====
    final double LAUNCHER_TARGET_VELOCITY = 1275;
    final double LAUNCHER_MIN_VELOCITY = 1250;

    final double FEED_TIME = 0.50;              // Push one ring
    final double BETWEEN_SHOTS_PAUSE = 1.0;    // Anti-jam pause changed to 1 sec inst of 0.2
    final double SPINUP_TIMEOUT = 3.0;          // Failsafe timeout

    @Override
    public void runOpMode() {


        // ===== Hardware Mapping =====
        frontLeft  = hardwareMap.dcMotor.get("left_front_drive");
        frontRight = hardwareMap.dcMotor.get("right_front_drive");
        backLeft   = hardwareMap.dcMotor.get("left_back_drive");
        backRight  = hardwareMap.dcMotor.get("right_back_drive");

        launcher   = hardwareMap.get(DcMotorEx.class, "launcher");
        leftFeeder = hardwareMap.get(CRServo.class, "left_feeder");
        rightFeeder= hardwareMap.get(CRServo.class, "right_feeder");

        // ===== Motor Directions (MATCH TELEOP) =====
        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.FORWARD);

        // ===== Drive Motor Behavior =====
        frontLeft.setZeroPowerBehavior(BRAKE);
        frontRight.setZeroPowerBehavior(BRAKE);
        backLeft.setZeroPowerBehavior(BRAKE);
        backRight.setZeroPowerBehavior(BRAKE);

        // ===== Launcher Setup =====
        launcher.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        launcher.setZeroPowerBehavior(BRAKE);

        // ===== Feeder Setup =====
        leftFeeder.setDirection(DcMotorSimple.Direction.REVERSE);
        leftFeeder.setPower(0);
        rightFeeder.setPower(0);

        telemetry.addLine("Autonomous Initialized");
        telemetry.update();

        waitForStart();
        if (!opModeIsActive()) return;

        // ==============================
        // 1️⃣ Move backward 27 inches
        // ==============================
        moveInches(27, 0.5, MoveDirection.BACKWARD);

        // ==============================
        // 2️⃣ Spin up launcher with failsafe
        // ==============================
        launcher.setVelocity(LAUNCHER_TARGET_VELOCITY);
        ElapsedTime spinupTimer = new ElapsedTime();

        while (opModeIsActive()
                && launcher.getVelocity() < LAUNCHER_MIN_VELOCITY
                && spinupTimer.seconds() < SPINUP_TIMEOUT) {
            telemetry.addLine("Autonomous Initialized");
            telemetry.update();
            telemetry.addData("Launcher Velocity", launcher.getVelocity());
            telemetry.addData("Target Velocity", LAUNCHER_TARGET_VELOCITY);
            telemetry.addData("Spinup Time", spinupTimer.seconds());
            telemetry.update();
            idle();
        }

        // FAILSAFE: abort shooting if never reached speed
        if (launcher.getVelocity() < LAUNCHER_MIN_VELOCITY) {
            telemetry.addLine("ERROR: Launcher failed to reach speed!");
            telemetry.update();
            return;
        }

        // ==============================
        // 3️⃣ Shoot 3 rings
        // ==============================
        ElapsedTime shotTimer = new ElapsedTime();
// Srikanth changed loop rounds to 4.
// Change :1
        for (int i = 0; i < 3 && opModeIsActive(); i++) {

            // Feed ring
            leftFeeder.setPower(1.0);
            rightFeeder.setPower(1.0);
            shotTimer.reset();
//added  code to reduce the power on first shot
            if (i==0){
                launcher.setVelocity(LAUNCHER_TARGET_VELOCITY-40);
            } else{
                launcher.setVelocity(LAUNCHER_TARGET_VELOCITY);
            }

            while (opModeIsActive() && shotTimer.seconds() < FEED_TIME) {
                telemetry.addData("Shot", i + 1);
                telemetry.addData("Launcher Velocity", launcher.getVelocity());
                telemetry.update();
                idle();
            }

            telemetry.addLine("Launcher: Target Velocity Achieved: Firing Shot");
            telemetry.update();
            // Stop feeders
            leftFeeder.setPower(0);
            rightFeeder.setPower(0);

            // Anti-jam pause
            shotTimer.reset();
            while (opModeIsActive() && shotTimer.seconds() < BETWEEN_SHOTS_PAUSE) {
                idle();
            }
        }

        // ==============================
        // 4️⃣ Move forward 26 inches
        // Srikanth removed the following line
        // Change :2
        // ==============================
        //moveInches(26, 0.5, MoveDirection.BACKWARD);

        // ==============================
        // 5️⃣ Strafe LEFT 18 inches
        // Change :3 Srikanth Changed direction from RIGHT to LEFT
        // ==============================
        moveInches(18, 0.5, MoveDirection.LEFT);
    }

    // ==================================================
    // ================= DRIVE HELPERS ==================
    // ==================================================

    enum MoveDirection { FORWARD, BACKWARD, LEFT, RIGHT }

    private void moveInches(double inches, double power, MoveDirection direction) {

        int countsPerRev = 537;     // GoBilda 312 RPM motor
        double wheelDiameter = 4.0;
        double countsPerInch = countsPerRev / (Math.PI * wheelDiameter);
        int counts = (int)(inches * countsPerInch);

        int fl = 0, fr = 0, bl = 0, br = 0;

        switch (direction) {
            case FORWARD:
                fl = fr = bl = br = counts;
                break;
            case BACKWARD:
                fl = fr = bl = br = -counts;
                break;
            case LEFT:
                fl = -counts; fr = counts; bl = counts; br = -counts;
                break;
            case RIGHT:
                fl = counts; fr = -counts; bl = -counts; br = counts;
                break;
        }

        frontLeft.setTargetPosition(frontLeft.getCurrentPosition() + fl);
        frontRight.setTargetPosition(frontRight.getCurrentPosition() + fr);
        backLeft.setTargetPosition(backLeft.getCurrentPosition() + bl);
        backRight.setTargetPosition(backRight.getCurrentPosition() + br);

        frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        frontLeft.setPower(power);
        frontRight.setPower(power);
        backLeft.setPower(power);
        backRight.setPower(power);

        while (opModeIsActive() &&
                (frontLeft.isBusy() || frontRight.isBusy()
                        || backLeft.isBusy() || backRight.isBusy())) {
            idle();
        }

        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }
}

